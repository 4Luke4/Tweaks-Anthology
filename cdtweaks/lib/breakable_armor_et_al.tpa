ACTION_DEFINE_ASSOCIATIVE_ARRAY cd_breakable_armor BEGIN

// generated by misc_tables.ods in /docs
//  ~item~, ~broken icon~, ~broken resref~, ~quality resref~ => ~quantity~ //notes
  ~chan01~, ~c!acc~, ~c!dacc~, ~chan01q~ => ~4~ //chain
  ~chan04~, ~c!acs~, ~c!dasc~, ~chan04q~ => ~3~ //splint
  ~helm01~, ~~, ~~, ~helm01q~ => ~10~ //helm
  ~plat01~, ~c!acp~, ~c!dape~, ~plat01q~ => ~2~ //plate
  ~shld01~, ~~, ~~, ~shld01q~ => ~10~ //shield
  ~shld03~, ~~, ~~, ~shld03q~ => ~10~ //shield
  ~shld05~, ~~, ~~, ~shld05q~ => ~7~ //shield
  ~shld08~, ~~, ~~, ~shld08q~ => ~10~ //shield
  ~shld09~, ~~, ~~, ~shld09q~ => ~10~ //shield
  ~shld10~, ~~, ~~, ~shld10q~ => ~10~ //shield
  ~shld11~, ~~, ~~, ~shld11q~ => ~10~ //shield
  ~shld12~, ~~, ~~, ~shld12q~ => ~10~ //shield
  ~shld13~, ~~, ~~, ~shld13q~ => ~5~ //shield
  ~shld14~, ~~, ~~, ~shld14q~ => ~5~ //shield
  ~shld15~, ~~, ~~, ~shld15q~ => ~3~ //shield
  ~shld16~, ~~, ~~, ~shld16q~ => ~3~ //shield
  ~plat04~, ~c!acf~, ~c!dafb~, ~plat04q~ => ~1~ //full plate
  ~_chan01~, ~c!acc~, ~c!daca~, ~~ => ~0~ //chain
  ~_chan04~, ~c!acs~, ~c!dasa~, ~~ => ~0~ //splint
  ~_helm01~, ~~, ~~, ~~ => ~0~ //helm
  ~_helm08~, ~~, ~~, ~~ => ~0~ //helm
  ~_helm09~, ~~, ~~, ~~ => ~0~ //helm
  ~_helm10~, ~~, ~~, ~~ => ~0~ //helm
  ~_helm11~, ~~, ~~, ~~ => ~0~ //helm
  ~_helm12~, ~~, ~~, ~~ => ~0~ //helm
  ~_helm13~, ~~, ~~, ~~ => ~0~ //helm
  ~_helm15~, ~~, ~~, ~~ => ~0~ //helm
  ~_ichan01~, ~c!acc~, ~c!dacb~, ~~ => ~0~ //chain
  ~_ichan04~, ~c!acs~, ~c!dasb~, ~~ => ~0~ //splint
  ~_ihelm01~, ~~, ~~, ~~ => ~0~ //helm
  ~_ihelm10~, ~~, ~~, ~~ => ~0~ //helm
  ~_iplat01~, ~c!acp~, ~c!dapa~, ~~ => ~0~ //plate
  ~_ishld03~, ~~, ~~, ~~ => ~0~ //shield
  ~_plat01~, ~c!acp~, ~c!dapb~, ~~ => ~0~ //plate
  ~_plat04~, ~c!acf~, ~c!dafa~, ~~ => ~0~ //full plate
  ~_plat07~, ~c!acf~, ~c!dafc~, ~~ => ~0~ //full plate
  ~_plat98~, ~c!acp~, ~c!dapc~, ~~ => ~0~ //plate
  ~_shld01~, ~~, ~~, ~~ => ~0~ //shield
  ~_shld03~, ~~, ~~, ~~ => ~0~ //shield
  ~_shld05~, ~~, ~~, ~~ => ~0~ //shield
  ~_shld08~, ~~, ~~, ~~ => ~0~ //shield
  ~_shld09~, ~~, ~~, ~~ => ~0~ //shield
  ~_shld10~, ~~, ~~, ~~ => ~0~ //shield
  ~_shld11~, ~~, ~~, ~~ => ~0~ //shield
  ~_shld12~, ~~, ~~, ~~ => ~0~ //shield
  ~_shld13~, ~~, ~~, ~~ => ~0~ //shield
  ~_shld14~, ~~, ~~, ~~ => ~0~ //shield
  ~_shld15~, ~~, ~~, ~~ => ~0~ //shield
  ~_shld16~, ~~, ~~, ~~ => ~0~ //shield
  ~_shld18~, ~~, ~~, ~~ => ~0~ //shield
  ~_shld99~, ~~, ~~, ~~ => ~0~ //shield
  ~dhelm01~, ~~, ~~, ~~ => ~0~ //helm
  ~dshld01~, ~~, ~~, ~~ => ~0~ //shield
  ~elfhelm~, ~~, ~~, ~~ => ~0~ //helm
  ~helm08~, ~~, ~~, ~~ => ~0~ //helm
  ~helm09~, ~~, ~~, ~~ => ~0~ //helm
  ~helm10~, ~~, ~~, ~~ => ~0~ //helm
  ~helm11~, ~~, ~~, ~~ => ~0~ //helm
  ~helm12~, ~~, ~~, ~~ => ~0~ //helm
  ~helm13~, ~~, ~~, ~~ => ~0~ //helm
  ~helm15~, ~~, ~~, ~~ => ~0~ //helm
  ~helm22~, ~~, ~~, ~~ => ~0~ //helm
  ~helmskwa~, ~~, ~~, ~~ => ~0~ //helm
  ~ichan01~, ~c!acc~, ~c!dacd~, ~~ => ~0~ //chain
  ~ichan04~, ~c!acc~, ~c!dace~, ~~ => ~0~ //chain
  ~ihelm01~, ~~, ~~, ~~ => ~0~ //helm
  ~ihelm10~, ~~, ~~, ~~ => ~0~ //helm
  ~iplat01~, ~c!acp~, ~c!dapd~, ~~ => ~0~ //plate
  ~ishld03~, ~~, ~~, ~~ => ~0~ //shield
  ~plat07~, ~c!acf~, ~c!dafd~, ~~ => ~0~ //full plate
  ~plat98~, ~c!acp~, ~c!dapf~, ~~ => ~0~ //plate
  ~plat99~, ~c!acp~, ~c!dapg~, ~~ => ~0~ //plate
  ~shld18~, ~~, ~~, ~~ => ~0~ //shield
  ~shld99~, ~~, ~~, ~~ => ~0~ //shield
  ~vischan1~, ~c!acc~, ~c!dacf~, ~~ => ~0~ //chain
  ~vischan2~, ~c!acs~, ~c!dasd~, ~~ => ~0~ //splint
  ~visplat1~, ~c!acp~, ~c!daph~, ~~ => ~0~ //plate

END

ACTION_IF game_is_totsc BEGIN // bg1 does this differently since there's no effect-on-hit opcode

  // PHASE #1 - adds opcode to selected armor/shield/helm, which change stat TRACKING (unused in original game) to 1,2,4 respectively, while equipped.
  // So we can tell the scripts, if the non-magic armor part is equipped. With disposable in BG1 script's triggers we can only check, if the person
  // has the item, but not, if the item is equipped or just in inventory. Opcode "store local variable" is not so good, because local variable is set
  // permanently while an item is equipping, and doesn't return to 0 itself, if the item is unequipped.

  APPEND ~action.ids~ ~160 ApplySpellRES(S:ResRef*,O:Target*)~       UNLESS ~ApplySpellRES~ // needed action

  // tracking effect added to items in mutual code section

  //PHASE #2 - script on party-NPC, which on conditions (person was hit, person is wearing an item that sets tracking to value > 0) with small
  //probability applies a spell to the person. The script DPLAYER3 works continuous on Player1 (all party in multiplayer), but DPLAYER2 could be
  //turned off with Party AI off. So we must add the script's blocks also to all OVERRIDE scripts of all joinable NPCs, also from mods. There is
  //unfortunately no possibility to check all party members from DPLAYER3, because trigger HitBy() can be proof only in script on active creature.
  ACTION_FOR_EACH script IN dplayer2 dplayer3 ajantis alora branwen coran dynaheir edwin eldoth faldorn garrick imoen jaheira khalid
    kagain kivan minsc montaron quayle safana sharteel skie tiax viconia xan xzar yeslick BEGIN // scripts for regular NPCs, so no existance check

    EXTEND_BOTTOM ~%script%.bcs~ ~cdtweaks/baf/bg1_break.baf~

  END

  ACTION_FOR_EACH script IN amorth aval01 bardo brager bub concho ferthgil jetlaya keiria skeezer thorf willsc wolfshd BEGIN // scripts for NPCs, so existance check included

    ACTION_IF FILE_EXISTS_IN_GAME ~%script%.bcs~ THEN BEGIN

      EXTEND_BOTTOM ~%script%.bcs~ ~cdtweaks/baf/bg1_break.baf~

    END

  END

  //7 NPCs from BG1 don't have OVERRIDE script
  COPY_EXISTING_REGEXP GLOB ~^alora[0-9]*\.cre$~ ~override~
      WRITE_ASCII SCRIPT_OVERRIDE ~alora~
      READ_ASCII SCRIPT_CLASS ~Class_Script_Name~ //Alora has already script ~alora.BCS~ but on CLASS position and with bad blocks
      PATCH_IF ( ~%Class_Script_Name%~ STRING_EQUAL_CASE ~alora~ ) THEN BEGIN  WRITE_ASCII SCRIPT_CLASS ~~ #8  END
    BUT_ONLY

  // delete broken junk in alora's script while we're here
  COPY_EXISTING ~alora.bcs~ ~override~
    DECOMPILE_AND_PATCH BEGIN
      REPLACE_TEXTUALLY ~TimeOfDay(DAY)~ ~False()~
    END
    BUT_ONLY

  COPY_EXISTING_REGEXP GLOB ~^branwe[0-9]*\.cre$~ ~override~
      WRITE_ASCII SCRIPT_OVERRIDE ~branwen~
    BUT_ONLY

  COPY_EXISTING_REGEXP GLOB ~^faldor[0-9]*\.cre$~ ~override~
      WRITE_ASCII SCRIPT_OVERRIDE ~faldorn~
    BUT_ONLY

  COPY_EXISTING_REGEXP GLOB ~^garric[0-9]*\.cre$~  ~override~
      WRITE_ASCII SCRIPT_OVERRIDE ~garrick~
     BUT_ONLY

  COPY_EXISTING_REGEXP GLOB ~^imoen[0-9]+\.cre$~   ~override~ // imoen1,2,4,6.CRE but not imoen.CRE
      WRITE_ASCII SCRIPT_OVERRIDE ~imoen~
    BUT_ONLY

  COPY_EXISTING_REGEXP GLOB ~^skie[0-9]*\.cre$~    ~override~
      WRITE_ASCII SCRIPT_OVERRIDE ~skie~
    BUT_ONLY

  COPY_EXISTING_REGEXP GLOB ~^xan[0-9]*\.cre$~     ~override~
      WRITE_ASCII SCRIPT_OVERRIDE ~xan~ #8
    BUT_ONLY

  //PHASE #3 - spell casted from scripts changes the item to the broken one and displays the massage. I don't know,
  //why in TUTU solution helms are handled different than armors and shields (broken armor and shield replace the
  //armor/shield direct in their equipping slot, but "broken item", that replace helm, is created in inventory, and
  //helm slot remains empty). If you prefer version from TUTU solution, I can modify this part of component.
  // done in mutual code section

END

COPY_EXISTING ~misc59.itm~ ~override/cddelhlm.itm~

// bgee freaks out with misc items in shield/armor/helmet slots
ACTION_IF enhanced_edition BEGIN // bgee, eet

  COPY_EXISTING ~misc57.itm~ ~override~ // broken shield
    WRITE_SHORT 0x1c 12
    WRITE_LONG  0x1e `0
    LPF ADD_ITEM_EQEFFECT INT_VAR opcode = 206 target = 1 parameter1 = `0 timing = 2 STR_VAR resource = cdbrak12 END
    BUT_ONLY

  COPY_EXISTING ~misc58.itm~ ~override~ // broken armor
    WRITE_SHORT 0x1c 2
    WRITE_LONG  0x1e `0
    LPF ADD_ITEM_EQEFFECT INT_VAR opcode = 206 target = 1 parameter1 = `0 timing = 2 STR_VAR resource = cdbrak2 END
    BUT_ONLY

  COPY_EXISTING ~cddelhlm.itm~ ~override~ // broken helmet
    WRITE_SHORT 0x1c 7
    WRITE_LONG  0x1e `0
    LPF ADD_ITEM_EQEFFECT INT_VAR opcode = 206 target = 1 parameter1 = `0 timing = 2 STR_VAR resource = cdbrak7 END
    BUT_ONLY

  COPY_EXISTING ~bprng1.itm~ ~override~ // slave ring from black pits - prevents weapon breakage; add armor/helm/shield
    PATCH_FOR_EACH int IN 2 7 12 BEGIN
      LPF CLONE_EFFECT INT_VAR match_opcode = 206 multi_match = 1 STR_VAR resource = EVAL ~cdbrak%int%~ END
    END
    BUT_ONLY

END

COPY ~cdtweaks/spl/cdbreak1.spl~ ~override/cdbrak2.spl~ // armor
  SET msg = RESOLVE_STR_REF(@106001)
  LPF ALTER_EFFECT INT_VAR match_opcode = 139 parameter1 = msg END

COPY_EXISTING ~cdbrak2.spl~ ~override/cdbrak7.spl~  // helm
  SET msg = RESOLVE_STR_REF(@106003)
  LPF ALTER_EFFECT INT_VAR match_opcode = 139 parameter1 = msg END
  LPF ALTER_EFFECT INT_VAR match_opcode = 143 parameter1 = 6 STR_VAR resource = ~cddelhlm~ END

COPY_EXISTING ~cdbrak2.spl~ ~override/cdbrak12.spl~  // shield
  SET msg = RESOLVE_STR_REF(@106002)
  LPF ALTER_EFFECT INT_VAR match_opcode = 139 parameter1 = msg END
  LPF ALTER_EFFECT INT_VAR match_opcode = 143 parameter1 = 9 STR_VAR resource = ~misc57~ END

COPY_EXISTING ~cddelhlm.itm~ ~override~ // broken helmet
  PATCH_IF ((enhanced_edition) OR (MOD_IS_INSTALLED ~tobex/tobex.tp2~ ~100~)) BEGIN // critical hit aversion from tobex or ee
    WRITE_BYTE 0x1b THIS | BIT1 // add flag so that it doens't prevent criticals
  END ELSE BEGIN // otherwise have helmet immediately destroy itself
    LPF ADD_ITEM_EQEFFECT INT_VAR opcode = 123 target = 1                timing = 1 insert_point = 0 STR_VAR resource = cddelhlm END
    LPF ADD_ITEM_EQEFFECT INT_VAR opcode = 122 target = 1 parameter1 = 1 timing = 1 insert_point = 0 STR_VAR resource = misc59 END
  END

// give nonmagical iron armor/shield/helmets a chance to break when attacked
OUTER_SPRINT taerum ~~
OUTER_SPRINT quality @106005
ACTION_PHP_EACH cd_breakable_armor AS params => quantity BEGIN

  ACTION_IF FILE_EXISTS_IN_GAME ~%params_0%.itm~ THEN BEGIN

    ACTION_IF enhanced_edition AND quantity BEGIN

      COPY_EXISTING ~%params_0%.itm~ ~override/%params_3%.itm~ // make quality version
        PATCH_FOR_EACH off IN 0x08 0x0c BEGIN
          READ_STRREF off name
          PATCH_IF ("%name%" STRING_COMPARE_REGEXP ~<Invalid Strref -?[0-9]+>~) BEGIN // checking for valid content in string
            INNER_PATCH_SAVE name ~%name%~ BEGIN
              REPLACE_TEXTUALLY ~\(.+\)~ ~%quality% \1~ // from 'foo' to 'quality foo'
            END
            SAY_EVALUATED off ~%name%~ // write changes
          END
        END

      OUTER_SPRINT taerum ~%taerum% AddStoreItem("taerum","%params_3%",%quantity%,1) RemoveStoreItem("taerum","%params_0%",0)~ // prep taerum's store updates

    END

    COPY_EXISTING ~%params_0%.itm~ ~override~
      READ_SHORT  0x1c type
      PATCH_IF game_is_totsc = 1 BEGIN
        PATCH_IF (type =  2) BEGIN SET track = 1 END ELSE // if armor tracking value 1
        PATCH_IF (type = 12) BEGIN SET track = 2 END ELSE // if shield tracking value 2
                             BEGIN SET track = 4 END      // if helm tracking value 4
        LPF ADD_ITEM_EQEFFECT INT_VAR opcode = 95 target = 1 timing = 2 parameter1 = track END // tracking value lets us do this via script
      END ELSE BEGIN
        LPF ADD_ITEM_EQEFFECT INT_VAR opcode = 232 target = 1 timing = 2 STR_VAR resource = EVAL "cdbrak%type%" END
      END
      BUT_ONLY

  END

END

ACTION_IF enhanced_edition BEGIN

  COPY_EXISTING ~baldur.bcs~ ~override~
    DECOMPILE_AND_PATCH BEGIN
      REPLACE_TEXTUALLY ~\(SetGlobal("bd_taerom_newitems","GLOBAL",1)\)~ ~%taerum% \1~
    END
    BUT_ONLY

END
